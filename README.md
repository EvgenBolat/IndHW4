# Хавронич Евгений Алексеевич, БПИ226
---
## Вариант 30
### Условие:
Военная операция. Темной-темной ночью прапорщики Иванов, Петров и Нечепорук занимаются хищением военного имущества со склада родной военной части. Будучи умными людьми и отличниками боевой и строевой подготовки, прапорщики ввели разделение труда. Иванов выносит имущество со склада и передает его в руки Петрову, который грузит его в грузовик. Нечепорук стоит на шухере и заодно подсчитывает рыночную стоимость добычи поле погрузки в грузовик очередной партии похищенного. Требуется составить многопоточное приложение, моделирующее деятельность прапорщиков–потоков. Необходимо учесть случайное время выполнения каждым прапорщиком своей боевой задачи и организовать в программе корректную их синхронизацию.
### Программы:
[Программы на ассемблере с комментариями размещены здесь](Files)

## Программа была написана на оценку 8.

### Требования на 8:
- В программу, наряду с выводом в консоль, добавлен вывод результатов в файл. Имя файла для вывода данных задается в командной строке как один из ее параметров. Итого список аргументов: ключ для определения ввода данных (0, если ввод числа в следующем аргументе или 1, если считать из файла), число или путь к файлу, откуда его необходимо считать, путь к файлу, куда необходимо записаь вывод.
- Результаты работы программы выводится на экран и записывается в файл.
- Наряду с вводом исходных данных через командную строку добавлен альтернативный вариант их ввода из файла, который по сути играет роль конфигурационного файла. Имя этого файла задается в командной строке вместо параметров, которые в этом случае не вводятся. Управление вводом в командной строке осуществляется с использованием соответствующих ключей( в качестве первого параметра передаются 0 или 1, см. первый пункт).
- Приведено не менее трех вариантов входных ([input1.txt](files/input1.txt), [input2.txt](files/input2.txt), [input3.txt](files/input3.txt)) и выходных([output1.txt](files/output1.txt), [output2.txt](files/output2.txt), [output3.txt](files/output3.txt)) файлов с различными исходным данными и результатами выполнения программы.
- Ввод данных из командной строки расширен с учетом введенных изменений (см. первый пункт).
<table>
    <tr>
        <th>№ теста</th>
        <th>Какую ситуацию проверяет</th>
        <th>Вывод</th>
        <th>Корректен?</th>
    </tr>
    <tr>
        <td>1</td>
        <td>Файл содержит число, не входящее в нужный диапозон (больше нуля)</td>
        <td>в файле должно быть число и больше нуля!</td>
        <td>Корректен, так как мы принимаем только положительные числа</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Файл содержит небольшое число</td>
        <td>В файле представлен вывод кражи 5 вещей</td>
        <td>Корректен, так как мы указали, что они будут красть 5 товаров</td>
    </tr>
    <tr>
        <td>3</td>
        <td>Файл содержит достаточно большое число (берём с тем учётом, что программа выполняется подольше на большем количестве предметов, поэтому 25 уже считается большим)</td>
        <td>В файле представлен вывод кражи 25 вещей</td>
        <td>Корректен, так как мы указали, что они будут красть 25 товаров</td>
    </tr>
</table>

### Требования на 6-7:
- В отчете подробно описан обобщенный алгоритм, используемый при реализации программы исходного словесного сценария. В котором показано, как на программу отображается каждый из субъектов предметной области.
Создаём три потока, олицетворяющих каждого человека из задания. У каждого потока есть своя функция:
1. У Иванова void* TakeOutGood(void* args) – принимает аргумент, который будет означать, сколько товаров ему необходимо украсть. Прежде всего оповещаем, что Иванов начинает работать, при помощи sleep делаем иллюзию по времени, что он какое-то время переносит(при этом время генерируется случайно в пределах
- В программу добавлена генерация случайных данных в допустимых диапазонах.
- Реализован ввод исходных данных из командной строки при запуске программы вместо ввода параметров с консоли во время выполнения программы.
- Результаты изменений отражены в отчете.

### Требования на 4-5:
- Приведено решение программы на ассемблере. Программа из файла читает данные. Результаты записываются в другой файл.
- Все изменяемые параметры программы вводятся с консоли.
- В программе присутствуют комментарии, поясняющие выполняемые ей действия.
- Обработка данных, полученных из файла сформирована в виде отдельной подпрограммы.
- В подкаталоге данных присутствуют файлы, используемые для тестирования.
- Буфер для текста программы имеет фиксированный размер размером не менее 4096 байт, допускающий ввод без искажений только тексты, ограниченные этим размером(сразу использовался буфер по критерию на 6-7 баллов)
- При чтении файла размером, превышающим размер буфера, не происходит падение программы. Программа корректно обрабатывает введенный «урезанный» текст.

## Общий алгоритм программы.
1. Вызов макроса **OpenFileAndReadMacro**. В качестве аргументов получаем регистр, в котором выбран тип ввода пути файла – 0, если из регистра, 1, если пользователем с консоли, а также просто любой регистр(если путь файла вводится пользователем), либо регистр, в котором содержится указатель на строку с путём к необходимому файлу. Возвращает в a0 дескриптор к указанному файлу для чтения (иначе выводит ошибку с неверным путём к файлу в консоль и программа корректно завершается) <br/> 
Внутри данного макроса вызывается подпрограмма **OpenForReadFileUni**, которая проверяет введённый тип введения пути файла и вызывает подпрограмму **OpenForReadFile**, которая уже возвращает дескриптор на нужный файл.
2. Вызов макроса **ReadAndCount**. В качестве аргумента поступает дескриптор файла, который будет читаться. Возвращает в a0 и a1 количества прописных и строчных латинских букв. <br/> 
Внутри данного макроса происходи вызов подпрограммы **ReadAndCount**, внутри которой при помощи подпрограммы **ReadFile** читается в цикле по 512 байт файл (максимум 10 кб в итоге), вызывается макрос **CountLetters** от прочитанных 512 байт, где уже подсчитывается количества прописных и строчных латинских букв от буфера. В цикле мы накапливаем количества прописных и строчных латинских букв от буфера.
3. Вызов макроса **WriteInConsole** – принимает на вход количества прописных и строчных латинских букв, спрашивает у пользователя с консоли, вывести ли их в консоль, и выводит, если он вводит Y, если N, то не выводит.
4. Вызов макроса **OpenAndWriteFileMacro**. Действует по аналогии с **OpenFileAndReadMacro**, только для записи файла. Вызывает два раза макрос WriteInt для записи сначала количества прописных букв, а потом количества строчных букв в файл. Между этими вызовами происходи вызов WriteChar, который ставит пробел в файле, чтобы числа не сливались.

## Замечение
Для тестовой программы с подпрограммами алгоритм аналогичен, так как вызываются подпрограммы, вокруг которых обёрнуты макросы из алгоритма выше. <br/> 
Для чистоты эксперимента в папку [OutputFiles](Files/OutputFiles) добавлен только файл вывода, если пользователь в главной программе в качестве пути введёт InputFiles/InputMain.txt, чтобы корректно отображалась папка – это сделано, чтобы при испытании файлов корректно создались файлы для вывода данных и они были изначально пустыми. В таблице будут отображены результаты выполнения тестовых программ. <br/> 
Также стоит отметить, что так как задание выполнялось на Mac, то в тестовых программах может возникнуть проблема с слэшами, их нужно просто исправить на слэши, используемые в вашей ОС (за неудобства приношу извинения, врать не стану, у меня при тестах на маке всё работало)
### Таблица прогона тестов
<table>
    <tr>
        <th>№ теста</th>
        <th>Какую ситуацию проверяет</th>
        <th>Что ожидалось в выводе программы</th>
        <th>Что вывела тестовая программа с подпрограммами</th>
        <th>Что вывела тестовая программа с макросами</th>
    </tr>
    <tr>
        <td>1</td>
        <td>Файл MainInput.txt (вводится пользователем с главной программы) Файл среднего размера с символами от 0 до 127</td>
        <td>1203 1198</td>
        <td>1203 1198</td>
        <td>1203 1198</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Файл Input1.txt. Пустой файл</td>
        <td>0 0</td>
        <td>0 0</td>
        <td>0 0</td>
    </tr>
    <tr>
        <td>3</td>
        <td>Файл Input2.txt. Файл с буквами ровно на 10 КБ</td>
        <td>5134 5106</td>
        <td>5134 5106</td>
        <td>5134 5106</td>
    </tr>
    <tr>
        <td>4</td>
        <td>Файл Input3.txt. Файл с буквами больше 10 КБ</td>
        <td>5117 5123</td>
        <td>5117 5123</td>
        <td>5117 5123</td>
    </tr>
    <tr>
        <td>5</td>
        <td>Файл Input4.txt. Файл только с прописными буквами </td>
        <td>5120 0</td>
        <td>5120 0</td>
        <td>5120 0</td>
    </tr>
    <tr>
        <td>6</td>
        <td>Файл Input5.txt. Файл только с строчными буквами </td>
        <td>0 1450</td>
        <td>0 1450</td>
        <td>0 1450</td>
    </tr>
    <tr>
        <td>7</td>
        <td>Файл Input6.txt. Файл ровно на 10 КБ, где только строчные буквы</td>
        <td>0 10240</td>
        <td>0 10240</td>
        <td>0 10240</td>
    </tr>
    <tr>
        <td>8</td>
        <td>Файл Input7.txt. Файл ровно на 10 КБ, где только прописные буквы</td>
        <td>10240 0</td>
        <td>10240 0</td>
        <td>10240 0</td>
    </tr>
</table>

![](https://i.pinimg.com/564x/de/57/8c/de578c0ef375d2ac999ea0c369c27d6e.jpg)
